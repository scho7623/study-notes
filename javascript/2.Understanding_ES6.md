#Understanding ES6 by Nicholas Zakas

##Chapter 1: Block Bindings
* Hoisting: Variables declared with `var` are treated as if they are at the top of the function
* ES6 introduces **block-level declaration** to provide more control over variable life cycle
  * Variables declared in a block scope are inaccessible outside the scope
  * Block scopes are created in
    * Inside a **function**
    * Inside a block (between `{` `}`)
* `let`: Similar to `var`, but only assessible in the current scope and won't be hoisted
* `const`: Constant which must be initialized on declaration and once declared, it cannot be reassigned
* Object declaration with `const`: Possible to modify object since it's not reassigning the `const` itself
```
const person = {}
person.name = 'Sungho'      // This is valid
person = { name: 'Sungho' } // This throws an error
```

* **Best practice**: Use `const` by default, only use `let` when you know a variable needs to be reassigned later!

##Chapter 2: Strings and Regular Expressions
* Surrogate pairs: A UTF-16 character that is represented with two 16-bit code units
* `codePointAt()`: Returns the Unicode code point at a given position
* `fromCodePoint()`: Returns a character corresponding to the given code point
* ES6 supports regular expression with `u` flag, which stands for Unicode: Use characters instead of code unit
* Regular expressions with `source` and `flags` property
* In addition to `indexOf()` to identify substring, following methods are added:
  * `includes(string, index)`: True if `string` found within the string searching from `index`
  * `startsWith(string, index)`: True if `string` found at the beginning of the string from `index`
  * `endsWith(string, index)`: True if `string` found at the end of the string searching from `length - index`
  * `repeat(n)`: Returns a new string repeating the original string `n` number of times

##Chapter 3: Functions
* **Default parameter values**: assign default value when the parameter isn't passed
```
function makeRequest(url, timeout = 2000, callback = function () {}) {
  // make a request with given timeout and callback
}
```
* In ES5 strict mode, the `arguments` object does not reflect changes to the named parameters
* Like ES5 strict mode, ES6 with default parameter does not change original `arguments` object
```
function someFunc(first, second = 'b') {
  console.log(arguments.lengt)         // 1
  console.log(first === arguments[0])  // true
  console.log(second === arguments[1]) // false
}
someFunc('a')
```
* Default parameter can be **any expression**, not just a primitive value
* **Rest parameter**
  * Indicated by three dots `...` in front of the named parameter
  * It becomes an array containing the rest of the parameters passed to a function
  * There can be only **one** rest parameter and it must be the **last** parameter
  * It cannot be used in **object literal setter**
* **Spread operator**: Split an array into separated arguments to be passed to a function
* **Arrow function**

##Chapter 4: Expanded Object Functionality
* Property initialization shorthand:
```
function createPerson(name, age) {
  return {
    name,
    age
  }
}
```
* Concise method:
```
const person = {
  name: 'Sungho',
  sayName() {
    console.log(this.name)
  }
}
```
* Computed property names:
```
const propName = 'location'
const person = {
  name: 'Sungho',
  [propName]: 'Palo Alto, CA'
}
console.log(person.location)  // 'Palo Alto, CA'
console.log(person[propName]) // 'Palo Also, CA'
```
*`Object.is()`: Returns true if two arguments are the same (same type and same valeu)
```
console.log(Object.is(5, 5))     // true
console.log(Object.is(5, '5'))   // false
console.log(Object.is(+0, -0))   // false
console.log(Object.is(NaN, NaN)) // true
```
* `Object.assign()`: Assign properties of one object to another and returns the object with additional properties
  * With multiple suppliers, the latter supplier overwrites the properties with the same name
```
let receiver = {}
Object.assign(receiver, {
  name: 'Sungho',
  location: 'Mountain View, CA'
}, {
  location: 'Palo Alto'
})
console.log(receiver.location)   // 'Palo Alto'
```

##Chapter 5: Destructuring
* **Destructuring**: Process of breaking down a data structure (object/array) into smaller parts
* Object destructuring
  * Example:
  ```
  const person = {
    name: 'Sungho',
    location: 'Palo Alto, CA'
  }
  const { name, location } = person
  console.log(name)      // 'Sungho'
  console.log(location)  // 'Palo Alto, CA'
  ```
  * Destructuring assignment:
  ```
  name = 'Tom'
  location = 'Mountain View, CA'
  ({ name, location } = person)  // make sure to wrap with parenthesis
  console.log(name)              // 'Sungho'
  console.log(location)          // 'Palo Alto, CA'
  ```
  * Default values
  ```
  const { name, location, occupation } = person
  console.log(name)       // 'Sungho'
  console.log(location)   // 'Palo Alto, CA'
  console.log(occupation) // undefined
  
  ({ occupation = 'Software Engineer' } = person)
  console.log(occupation) // 'Software Engineer'
  ```
  * Assigning to different local variable names
  ```
  const { name: localName, location: localLocation, occupation: localOcc = 'Software Engineer' } = person
  console.log(localName)     // 'Sungho'
  console.log(localLocation) // 'Palo Alto, CA'
  console.log(localOcc)      // 'Software Engineer'
  ```
  * Nested object destructuring
  ```
  const person = {
    name: 'Sungho',
    skills: {
      javascript: [
        'ES6',
        'React',
        'Redux'
      ]
    }
  }
  const { skills: { javascript } } = person
  console.log(javascript.length)     // 3
  console.log(javascript.join(','))  // 'ES6','React','Redux'
  
  const { skills: { javascript: js } } = person  // Assigning to different local variable name is possible
  console.log(js.length)        // 3
  console.log(js.join(','))     // 'ES6','React','Redux'
  ```
* Array destructuring
  * Array destructuring works on positions rather than the named properties in object
  ```
  const javascript = [ 'ES6', 'React', 'Redux' ]
  const [ firstJS, secondJS ] = javascript
  console.log(firstJS)   // 'ES6'
  console.log(secondJS)  // 'React'
  ```
  * You can skip any variables you want to ignore by only providing variable names you are interested only
  ```
  const [ , , thirdJS ] = javascript
  console.log(thirdJS)   // 'Redux'
  ```
  * Swapping variables using array destructuring
  ```
  let a = 1
  let b = 2
  [ a, b ] = [ b, a ]
  console.log(a)        // 2
  console.log(b)        // 1
  ```
  * Nested array destructuring
  ```
  const skills = [ 'Java', 'C', ['ES6', 'React', 'Redux'] ]
  const [ firstSkill, secondSkill, [thirdSkill] ] = skills
  console.log(firstSkill)    // 'Java'
  console.log(secondSkill)   // 'C'
  console.log(thirdSkill)    // 'ES6'
  ```
  * **Rest Items**: Assign remaining items in an array
  ```
  const javascript = [ 'ES6', 'React', 'Redux' ]
  const [ firstSkill, ...restSkills ] = javascript
  console.log(firstSkill)           // 'ES6'
  console.log(restSkills.length)    // 2
  console.log(restSkills[0])        // 'React'
  console.log(restSkills[1])        // 'Redux'
  ```
  * Cloning with rest items
  ```
  const javascript = [ 'ES6', 'React', 'Redux' ]
  const [ ...cloneJS ] = javascript
  console.log(cloneJS)  // [ 'ES6', 'React', 'Redux' ]
  ```
* Mixed destructuring: Mix of object and array destructuring
```
const person = {
  name: 'Sungho',
  location: {
    street: 'University Ave',
    city: 'Palo Alto',
    state: 'CA'
  },
  skills: [
    'JavaScript',
    'Java',
    'C'
  ]
}
const {
  location: { city: localCity },
  skills: [ firstSkill ]
} = person
console.log(localCity)     // 'Palo Alto'
console.log(firstSkill)    // 'JavaScript'
```
* Destructured parameters
```
function setCookie(name, value, { secure, path, domain, expires } = {}) {
  // code to set the cookie
}

setCookie('type', 'js', {
  secure: true,
  expires: 60000
})
```
